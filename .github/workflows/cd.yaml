name: CD

on:
  pull_request:
    types:
      - closed

permissions: {}

jobs:
  release:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    permissions:
      contents: write
      actions: read

    strategy:
      matrix:
        os: [linux, darwin, windows]
        arch: [amd64, arm64]
        exclude:
          - os: windows
            arch: arm64

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Get the pull request number
        id: get_pr_number
        uses: actions/github-script@v7
        with:
          script: |
            const pr_number = context.payload.pull_request.number;
            if (!pr_number) {
              throw new Error('Pull request number is undefined.');
            }
            core.setOutput('pr_number', pr_number)

      - name: Get the CI Workflow ID
        id: get_ci_workflow_id
        uses: actions/github-script@v7
        with:
          script: |
            const workflows = await github.rest.actions.listRepoWorkflows({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            const ciWorkflow = workflows.data.workflows.find(wf => wf.name === 'CI');
            if (!ciWorkflow) {
              throw new Error('CI workflow not found.');
            }
            core.setOutput('workflow_id', ciWorkflow.id);

      - name: Get the workflow run ID
        id: get_run_id
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = '${{ steps.get_pr_number.outputs.pr_number }}';
            if (!prNumber) {
              throw new Error('Pull request number is undefined.');
            }

            // Fetch the pull request details to get the head SHA
            const { data: pullRequest } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            const headSha = pullRequest.head.sha;

            // Get CI Workflow ID from previous step
            const workflowId = '${{ steps.get_ci_workflow_id.outputs.workflow_id }}';

            // List workflow runs for the CI workflow
            const runs = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: workflowId,
              head_sha: headSha,
              status: 'completed'
            });

            // Find the latest matching run
            const matchingRun = runs.data.workflow_runs[0];

            if (!matchingRun) {
              throw new Error('No CI workflow run found for the PR head SHA.');
            }

            // Log available artifacts for debugging
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: matchingRun.id
            });

            console.log('Available Artifacts:', artifacts.data.artifacts.map(a => a.name));

            const runId = matchingRun.id;
            core.setOutput('run_id', runId)

      - name: Download Binaries
        uses: actions/download-artifact@v4
        with:
          name: k8s-backup-restore-binaries-${{ matrix.os }}-${{ matrix.arch }}
          path: ./binaries/${{ matrix.os }}/${{ matrix.arch }}
          run-id: ${{ steps.get_run_id.outputs.run_id }}

      - name: Create Release
        id: create_release
        uses: actions/github-script@v7
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const core = require('@actions/core');
            const github = require('@actions/github');

            const getNextVersion = (currentVersion) => {
              const versionParts = currentVersion.replace('v', '').split('.');
              const major = parseInt(versionParts[0]);
              const minor = parseInt(versionParts[1]);
              const patch = parseInt(versionParts[2]) + 1;
              return `v${major}.${minor}.${patch}`;
            };

            const { data: latestRelease } = await github.repos.getLatestRelease({
              owner: context.repo.owner,
              repo: context.repo.repo
            });

            if (!latestRelease) {
              throw new Error('No latest release found.');
            }

            const nextVersion = getNextVersion(latestRelease.tag_name);

            const { data: release } = await github.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: nextVersion,
              name: `Release ${nextVersion}`,
              body: `Release ${nextVersion} of k8s-backup-restore.`,
              draft: false,
              prerelease: false
            });

            core.setOutput('release_id', release.id);
            core.setOutput('upload_url', release.upload_url);
            core.setOutput('tag_name', nextVersion);

      - name: Upload Binary
        uses: actions/github-script@v7
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const fs = require('fs');
            const osType = '${{ matrix.os }}';
            const arch = '${{ matrix.arch }}';
            const path = `./binaries/${osType}/${arch}/k8s-backup-restore-${osType}-${arch}`;

            if (!fs.existsSync(path)) {
              throw new Error(`Binary not found at path: ${path}`);
            }

            const content = fs.readFileSync(path);
            const releaseId = '${{ steps.create_release.outputs.release_id }}';

            await github.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              name: `k8s-backup-restore-${osType}-${arch}`,
              data: content,
              headers: {
                'content-type': 'application/octet-stream',
                'content-length': content.length
              }
            });
